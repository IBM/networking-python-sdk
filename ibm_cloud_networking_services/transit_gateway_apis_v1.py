# coding: utf-8

# (C) Copyright IBM Corp. 2021.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# IBM OpenAPI SDK Code Generator Version: 3.10.3-18e3fe12-20200803-172650
 
"""
No description provided (generated by Openapi Generator
https://github.com/openapitools/openapi-generator)
"""

from datetime import datetime
from enum import Enum
from typing import Dict, List
import json

from ibm_cloud_sdk_core import BaseService, DetailedResponse
from ibm_cloud_sdk_core.authenticators.authenticator import Authenticator
from ibm_cloud_sdk_core.get_authenticator import get_authenticator_from_environment
from ibm_cloud_sdk_core.utils import convert_model, datetime_to_string, string_to_datetime

from .common import get_sdk_headers

##############################################################################
# Service
##############################################################################

class TransitGatewayApisV1(BaseService):
    """The Transit Gateway Apis V1 service."""

    DEFAULT_SERVICE_URL = 'https://transit.cloud.ibm.com/v1'
    DEFAULT_SERVICE_NAME = 'transit_gateway_apis'

    @classmethod
    def new_instance(cls,
                     version: str,
                     service_name: str = DEFAULT_SERVICE_NAME,
                    ) -> 'TransitGatewayApisV1':
        """
        Return a new client for the Transit Gateway Apis service using the
               specified parameters and external configuration.

        :param str version: Requests the version of the API as of a date in the
               format `YYYY-MM-DD`. Any date up to the current date may be provided.
               Specify the current date to request the latest version.
        """
        if version is None:
            raise ValueError('version must be provided')

        authenticator = get_authenticator_from_environment(service_name)
        service = cls(
            version,
            authenticator
            )
        service.configure_service(service_name)
        return service

    def __init__(self,
                 version: str,
                 authenticator: Authenticator = None,
                ) -> None:
        """
        Construct a new client for the Transit Gateway Apis service.

        :param str version: Requests the version of the API as of a date in the
               format `YYYY-MM-DD`. Any date up to the current date may be provided.
               Specify the current date to request the latest version.

        :param Authenticator authenticator: The authenticator specifies the authentication mechanism.
               Get up to date information from https://github.com/IBM/python-sdk-core/blob/master/README.md
               about initializing the authenticator of your choice.
        """
        if version is None:
            raise ValueError('version must be provided')

        BaseService.__init__(self,
                             service_url=self.DEFAULT_SERVICE_URL,
                             authenticator=authenticator)
        self.version = version


    #########################
    # transitConnections
    #########################


    def list_connections(self,
        *,
        limit: int = None,
        start: str = None,
        network_id: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Retrieves all connections.

        List all transit gateway connections associated with this account.

        :param int limit: (optional) The maximum number of resources to return per
               page.
        :param str start: (optional) A server supplied token determining which
               resource to start the page on.
        :param str network_id: (optional) Search for connections with the given
               network_id value.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TransitConnectionCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_connections')
        headers.update(sdk_headers)

        params = {
            'version': self.version,
            'limit': limit,
            'start': start,
            'network_id': network_id
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/connections'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response

    #########################
    # transitGateways
    #########################


    def list_transit_gateways(self,
        *,
        limit: int = None,
        start: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Retrieves all Transit Gateways.

        List all Transit Gateways in account the caller is authorized to view.

        :param int limit: (optional) The maximum number of resources to return per
               page.
        :param str start: (optional) A server supplied token determining which
               resource to start the page on.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TransitGatewayCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_transit_gateways')
        headers.update(sdk_headers)

        params = {
            'version': self.version,
            'limit': limit,
            'start': start
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/transit_gateways'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_transit_gateway(self,
        location: str,
        name: str,
        *,
        global_: bool = None,
        resource_group: 'ResourceGroupIdentity' = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Creates a Transit Gateway.

        Create a Transit Gateway based on the supplied input template.

        :param str location: Location of Transit Gateway Services.
        :param str name: Name Transit Gateway Services.
        :param bool global_: (optional) Allow global routing for a Transit Gateway.
               If unspecified, the default value is false.
        :param ResourceGroupIdentity resource_group: (optional) The resource group
               to use. If unspecified, the account's [default resource
               group](https://console.bluemix.net/apidocs/resource-manager#introduction)
               is used.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TransitGateway` object
        """

        if location is None:
            raise ValueError('location must be provided')
        if name is None:
            raise ValueError('name must be provided')
        if resource_group is not None:
            resource_group = convert_model(resource_group)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='create_transit_gateway')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        data = {
            'location': location,
            'name': name,
            'global': global_,
            'resource_group': resource_group
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/transit_gateways'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       params=params,
                                       data=data)

        response = self.send(request)
        return response


    def delete_transit_gateway(self,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Deletes specified Transit Gateway.

        This request deletes a Transit Gateway. This operation cannot be reversed. For
        this request to succeed, the Transit Gateway must not contain connections.

        :param str id: The Transit Gateway identifier.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='delete_transit_gateway')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/transit_gateways/{0}'.format(
            *self.encode_path_vars(id))
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_transit_gateway(self,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Retrieves specified Transit Gateway.

        This request retrieves a single Transit Gateway specified by the identifier in the
        URL.

        :param str id: The Transit Gateway identifier.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TransitGateway` object
        """

        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_transit_gateway')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/transit_gateways/{0}'.format(
            *self.encode_path_vars(id))
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def update_transit_gateway(self,
        id: str,
        *,
        global_: bool = None,
        name: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Updates specified Transit Gateway.

        This request updates a Transit Gateway's name and/or global flag.

        :param str id: The Transit Gateway identifier.
        :param bool global_: (optional) Allow global routing for a Transit Gateway.
        :param str name: (optional) The user-defined name for this transit gateway.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TransitGateway` object
        """

        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='update_transit_gateway')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        data = {
            'global': global_,
            'name': name
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/transit_gateways/{0}'.format(
            *self.encode_path_vars(id))
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       params=params,
                                       data=data)

        response = self.send(request)
        return response

    #########################
    # transitGatewaysNetworkConnections
    #########################


    def list_transit_gateway_connections(self,
        transit_gateway_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Retrieves all connections in a Transit Gateway.

        This request retrieves all connections in a Transit Gateway.

        :param str transit_gateway_id: The Transit Gateway identifier.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TransitGatewayConnectionCollection` object
        """

        if transit_gateway_id is None:
            raise ValueError('transit_gateway_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_transit_gateway_connections')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/transit_gateways/{0}/connections'.format(
            *self.encode_path_vars(transit_gateway_id))
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_transit_gateway_connection(self,
        transit_gateway_id: str,
        network_type: str,
        *,
        base_connection_id: str = None,
        local_gateway_ip: str = None,
        local_tunnel_ip: str = None,
        name: str = None,
        network_account_id: str = None,
        network_id: str = None,
        remote_bgp_asn: str = None,
        remote_gateway_ip: str = None,
        remote_tunnel_ip: str = None,
        zone: 'ZoneIdentity' = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Add connection to a Transit Gateway.

        Add a connection to Transit Gateway.

        :param str transit_gateway_id: The Transit Gateway identifier.
        :param str network_type: Defines what type of network is connected via this
               connection. For access to gre_tunnel connections contact IBM support.
        :param str base_connection_id: (optional) network_type 'gre_tunnel'
               connections must be created over an existing network_type 'classic'
               connection. This field is required for 'gre_tunnel' connections and must
               specify the ID of an active transit gateway network_type 'classic'
               connection in the same transit gateway. Omit 'base_connection_id' for any
               connection type other than 'gre_tunnel'.
        :param str local_gateway_ip: (optional) Local gateway IP address.  This
               field is required for and only applicable to type gre_tunnel connections.
        :param str local_tunnel_ip: (optional) Local tunnel IP address.  This field
               is required for and only applicable to type gre_tunnel connections.  The
               local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30
               network.  Neither can be the network nor broadcast addresses.
        :param str name: (optional) The user-defined name for this transit gateway
               connection. Network type 'vpc'  connections are defaulted to the name of
               the VPC.  Network type 'classic' connections are named 'Classic'.   Name
               specification is required for network type 'gre_tunnel' connections.
        :param str network_account_id: (optional) The ID of the account which owns
               the network that is being connected. Generally only used if the network is
               in a different account than the gateway. This field is required to be
               unspecified for network type 'gre_tunnel'.
        :param str network_id: (optional) The ID of the network being connected via
               this connection. This field is required for some types, such as 'vpc'. For
               network type 'vpc' this is the CRN of the VPC to be connected. This field
               is required to be unspecified for network type 'classic' and 'gre_tunnel'
               connections.
        :param str remote_bgp_asn: (optional) Remote network BGP ASN.  This field
               is only applicable to 'gre_tunnel' type connections. The following ASN
               values are reserved and unavailable 64512-64513, 65100, 65201-65234,
               65402-65433, 65500 and 4201065000-4201065999. If 'remote_bgp_asn' is
               omitted on gre_tunnel connection create requests IBM will assign an ASN.
        :param str remote_gateway_ip: (optional) Remote gateway IP address.  This
               field is required for and only applicable to type gre_tunnel connections.
        :param str remote_tunnel_ip: (optional) Remote tunnel IP address.  This
               field is required for and only applicable to type gre_tunnel connections.
               The  local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30
               network.  Neither can be the network nor broadcast addresses.
        :param ZoneIdentity zone: (optional) For network_type 'gre_tunnel'
               connections specify the connection's location.  The specified availability
               zone must reside in the gateway's region.
               Use the IBM Cloud global catalog to list zones within the desired region.
               This field is required for and only applicable to network type 'gre_tunnel'
               connections.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TransitGatewayConnectionCust` object
        """

        if transit_gateway_id is None:
            raise ValueError('transit_gateway_id must be provided')
        if network_type is None:
            raise ValueError('network_type must be provided')
        if zone is not None:
            zone = convert_model(zone)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='create_transit_gateway_connection')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        data = {
            'network_type': network_type,
            'base_connection_id': base_connection_id,
            'local_gateway_ip': local_gateway_ip,
            'local_tunnel_ip': local_tunnel_ip,
            'name': name,
            'network_account_id': network_account_id,
            'network_id': network_id,
            'remote_bgp_asn': remote_bgp_asn,
            'remote_gateway_ip': remote_gateway_ip,
            'remote_tunnel_ip': remote_tunnel_ip,
            'zone': zone
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/transit_gateways/{0}/connections'.format(
            *self.encode_path_vars(transit_gateway_id))
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       params=params,
                                       data=data)

        response = self.send(request)
        return response


    def delete_transit_gateway_connection(self,
        transit_gateway_id: str,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Remove connection from Transit Gateway.

        After the specified connection is detached, entities still within the Transit
        Gateway will no longer be able to communicate directly to it through the IBM Cloud
        private backbone.

        :param str transit_gateway_id: The Transit Gateway identifier.
        :param str id: The connection identifier.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if transit_gateway_id is None:
            raise ValueError('transit_gateway_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='delete_transit_gateway_connection')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/transit_gateways/{0}/connections/{1}'.format(
            *self.encode_path_vars(transit_gateway_id, id))
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_transit_gateway_connection(self,
        transit_gateway_id: str,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Retrieves specified Transit Gateway connection.

        This request retrieves a connection from the Transit Gateway.

        :param str transit_gateway_id: The Transit Gateway identifier.
        :param str id: The connection identifier.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TransitGatewayConnectionCust` object
        """

        if transit_gateway_id is None:
            raise ValueError('transit_gateway_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_transit_gateway_connection')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/transit_gateways/{0}/connections/{1}'.format(
            *self.encode_path_vars(transit_gateway_id, id))
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def update_transit_gateway_connection(self,
        transit_gateway_id: str,
        id: str,
        *,
        name: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Updates specified Transit Gateway connection.

        Update the name of a connection to a Transit Gateway.

        :param str transit_gateway_id: The Transit Gateway identifier.
        :param str id: The connection identifier.
        :param str name: (optional) The user-defined name for this transit gateway.
               If specified as empty string or nil,  the name will be the network name
               (the name of the VPC in the case of network type 'vpc',  and the word
               Classic, in the case of network type 'classic').
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TransitGatewayConnectionCust` object
        """

        if transit_gateway_id is None:
            raise ValueError('transit_gateway_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='update_transit_gateway_connection')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        data = {
            'name': name
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/transit_gateways/{0}/connections/{1}'.format(
            *self.encode_path_vars(transit_gateway_id, id))
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       params=params,
                                       data=data)

        response = self.send(request)
        return response


    def create_transit_gateway_connection_actions(self,
        transit_gateway_id: str,
        id: str,
        action: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Perform actions on a connection for a Transit Gateway.

        Allow a network owner to approve or reject a cross-account connection request.

        :param str transit_gateway_id: The Transit Gateway identifier.
        :param str id: The connection identifier.
        :param str action: The action that is to be performed against the
               connection request.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if transit_gateway_id is None:
            raise ValueError('transit_gateway_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        if action is None:
            raise ValueError('action must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='create_transit_gateway_connection_actions')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        data = {
            'action': action
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/transit_gateways/{0}/connections/{1}/actions'.format(
            *self.encode_path_vars(transit_gateway_id, id))
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       params=params,
                                       data=data)

        response = self.send(request)
        return response

    #########################
    # transitLocation
    #########################


    def list_gateway_locations(self,
        **kwargs
    ) -> DetailedResponse:
        """
        List all locations that support Transit Gateways.

        List all locations that support Transit Gateways.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TSCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_gateway_locations')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/locations'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_gateway_location(self,
        name: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Show the details of a given Transit Gateway location.

        Get the details of a Transit Gateway Location.

        :param str name: The Transit Gateway location Name.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TSLocation` object
        """

        if name is None:
            raise ValueError('name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_gateway_location')
        headers.update(sdk_headers)

        params = {
            'version': self.version
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/locations/{0}'.format(
            *self.encode_path_vars(name))
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


##############################################################################
# Models
##############################################################################


class ResourceGroupIdentity():
    """
    The resource group to use. If unspecified, the account's [default resource
    group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.

    :attr str id: The unique identifier for this resource group.
    """

    def __init__(self,
                 id: str) -> None:
        """
        Initialize a ResourceGroupIdentity object.

        :param str id: The unique identifier for this resource group.
        """
        self.id = id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceGroupIdentity':
        """Initialize a ResourceGroupIdentity object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ResourceGroupIdentity JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceGroupIdentity object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceGroupIdentity object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceGroupIdentity') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceGroupIdentity') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ResourceGroupReference():
    """
    The resource group to use. If unspecified, the account's [default resource
    group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.

    :attr str id: The unique identifier for this resource group.
    :attr str href: The URL for this resource group.
    """

    def __init__(self,
                 id: str,
                 href: str) -> None:
        """
        Initialize a ResourceGroupReference object.

        :param str id: The unique identifier for this resource group.
        :param str href: The URL for this resource group.
        """
        self.id = id
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceGroupReference':
        """Initialize a ResourceGroupReference object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ResourceGroupReference JSON')
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in ResourceGroupReference JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceGroupReference object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceGroupReference object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceGroupReference') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceGroupReference') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TSCollection():
    """
    A list of Transit Gateway locations.

    :attr List[TSLocationBasic] locations: Collection of Transit Gateway locations.
    """

    def __init__(self,
                 locations: List['TSLocationBasic']) -> None:
        """
        Initialize a TSCollection object.

        :param List[TSLocationBasic] locations: Collection of Transit Gateway
               locations.
        """
        self.locations = locations

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TSCollection':
        """Initialize a TSCollection object from a json dictionary."""
        args = {}
        if 'locations' in _dict:
            args['locations'] = [TSLocationBasic.from_dict(x) for x in _dict.get('locations')]
        else:
            raise ValueError('Required property \'locations\' not present in TSCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TSCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'locations') and self.locations is not None:
            _dict['locations'] = [x.to_dict() for x in self.locations]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TSCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TSCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TSCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TSLocalLocation():
    """
    Details of a local connection location.

    :attr str display_name: (optional) A descriptive display name for the location.
    :attr str name: (optional) The name of the location.
    :attr str type: (optional) The type of the location, determining is this a
          multi-zone region, a single data center, or a point of presence. The list of
          enumerated values for this property may expand in the future. Code and processes
          using this field must tolerate unexpected values.
    """

    def __init__(self,
                 *,
                 display_name: str = None,
                 name: str = None,
                 type: str = None) -> None:
        """
        Initialize a TSLocalLocation object.

        :param str display_name: (optional) A descriptive display name for the
               location.
        :param str name: (optional) The name of the location.
        :param str type: (optional) The type of the location, determining is this a
               multi-zone region, a single data center, or a point of presence. The list
               of enumerated values for this property may expand in the future. Code and
               processes using this field must tolerate unexpected values.
        """
        self.display_name = display_name
        self.name = name
        self.type = type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TSLocalLocation':
        """Initialize a TSLocalLocation object from a json dictionary."""
        args = {}
        if 'display_name' in _dict:
            args['display_name'] = _dict.get('display_name')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TSLocalLocation object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'display_name') and self.display_name is not None:
            _dict['display_name'] = self.display_name
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TSLocalLocation object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TSLocalLocation') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TSLocalLocation') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        The type of the location, determining is this a multi-zone region, a single data
        center, or a point of presence. The list of enumerated values for this property
        may expand in the future. Code and processes using this field must tolerate
        unexpected values.
        """
        REGION = 'region'


class TSLocation():
    """
    Details of a Transit Gateway location.

    :attr str billing_location: The geographical location of this location, used for
          billing purposes.
    :attr str name: Name of the Location.
    :attr str type: The type of the location, determining is this a multi-zone
          region, a single data center, or a point of presence.
    :attr List[TSLocalLocation] local_connection_locations: The set of network
          locations that are considered local for this Transit Gateway location.
    """

    def __init__(self,
                 billing_location: str,
                 name: str,
                 type: str,
                 local_connection_locations: List['TSLocalLocation']) -> None:
        """
        Initialize a TSLocation object.

        :param str billing_location: The geographical location of this location,
               used for billing purposes.
        :param str name: Name of the Location.
        :param str type: The type of the location, determining is this a multi-zone
               region, a single data center, or a point of presence.
        :param List[TSLocalLocation] local_connection_locations: The set of network
               locations that are considered local for this Transit Gateway location.
        """
        self.billing_location = billing_location
        self.name = name
        self.type = type
        self.local_connection_locations = local_connection_locations

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TSLocation':
        """Initialize a TSLocation object from a json dictionary."""
        args = {}
        if 'billing_location' in _dict:
            args['billing_location'] = _dict.get('billing_location')
        else:
            raise ValueError('Required property \'billing_location\' not present in TSLocation JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TSLocation JSON')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in TSLocation JSON')
        if 'local_connection_locations' in _dict:
            args['local_connection_locations'] = [TSLocalLocation.from_dict(x) for x in _dict.get('local_connection_locations')]
        else:
            raise ValueError('Required property \'local_connection_locations\' not present in TSLocation JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TSLocation object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'billing_location') and self.billing_location is not None:
            _dict['billing_location'] = self.billing_location
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'local_connection_locations') and self.local_connection_locations is not None:
            _dict['local_connection_locations'] = [x.to_dict() for x in self.local_connection_locations]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TSLocation object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TSLocation') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TSLocation') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TSLocationBasic():
    """
    Details of a Transit Gateway location.

    :attr str billing_location: The geographical location of this location, used for
          billing purposes.
    :attr str name: Name of the Location.
    :attr str type: The type of the location, determining is this a multi-zone
          region, a single data center, or a point of presence.
    """

    def __init__(self,
                 billing_location: str,
                 name: str,
                 type: str) -> None:
        """
        Initialize a TSLocationBasic object.

        :param str billing_location: The geographical location of this location,
               used for billing purposes.
        :param str name: Name of the Location.
        :param str type: The type of the location, determining is this a multi-zone
               region, a single data center, or a point of presence.
        """
        self.billing_location = billing_location
        self.name = name
        self.type = type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TSLocationBasic':
        """Initialize a TSLocationBasic object from a json dictionary."""
        args = {}
        if 'billing_location' in _dict:
            args['billing_location'] = _dict.get('billing_location')
        else:
            raise ValueError('Required property \'billing_location\' not present in TSLocationBasic JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TSLocationBasic JSON')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in TSLocationBasic JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TSLocationBasic object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'billing_location') and self.billing_location is not None:
            _dict['billing_location'] = self.billing_location
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TSLocationBasic object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TSLocationBasic') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TSLocationBasic') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TransitConnection():
    """
    Transit gateway connection.

    :attr str base_connection_id: (optional) network_type 'gre_tunnel' connections
          use 'base_connection_id' to specify the id of a network_type 'classic'
          connection the tunnel is configured over. The specified connection must reside
          in the same transit gateway and be in an active state. The 'classic' connection
          cannot be deleted until any 'gre_tunnel' connections using it are deleted. This
          field only applies to and is required for network type 'gre_tunnel' connections.
    :attr datetime created_at: The date and time that this connection was created.
    :attr str id: The unique identifier for this connection.
    :attr int local_bgp_asn: (optional) Local network BGP ASN.  This field only
          applies to network type 'gre_tunnel' connections.
    :attr str local_gateway_ip: (optional) Local gateway IP address.  This field
          only applies to network type 'gre_tunnel' connections.
    :attr str local_tunnel_ip: (optional) Local tunnel IP address.  This field only
          applies to network type 'gre_tunnel' connections.
    :attr int mtu: (optional) GRE tunnel MTU.  This field only applies to network
          type 'gre_tunnel' connections.
    :attr str name: The user-defined name for this transit gateway connection.
    :attr str network_account_id: (optional) The ID of the account which owns the
          connected network. Generally only used if the network is in a different IBM
          Cloud account than the gateway.
    :attr str network_id: (optional) The ID of the network being connected via this
          connection. This field is required for some types, such as 'vpc'. For network
          type 'vpc' this is the CRN of the VPC to be connected.
    :attr str network_type: Defines what type of network is connected via this
          connection. The list of enumerated values for this property may expand in the
          future. Code and processes using this field must tolerate unexpected values.
    :attr int remote_bgp_asn: (optional) Remote network BGP ASN.  This field only
          applies to network type 'gre_tunnel' connections.
    :attr str remote_gateway_ip: (optional) Remote gateway IP address.  This field
          only applies to network type 'gre_tunnel' connections.
    :attr str remote_tunnel_ip: (optional) Remote tunnel IP address.  This field
          only applies to network type 'gre_tunnel' connections.
    :attr str request_status: (optional) Only visible for cross account connections,
          this field represents the status of a connection request between IBM Cloud
          accounts. The list of enumerated values for this property may expand in the
          future. Code and processes using this field must tolerate unexpected values.
    :attr str status: Connection state. The list of enumerated values for this
          property may expand in the future. Code and processes using this field must
          tolerate unexpected values.
    :attr TransitGatewayReference transit_gateway: Reference to the transit gateway
          that contains this connection.
    :attr datetime updated_at: (optional) The date and time that this connection was
          last updated.
    :attr ZoneReference zone: (optional) Location of GRE tunnel.  This field only
          applies to network type 'gre_tunnel' connections.
    """

    def __init__(self,
                 created_at: datetime,
                 id: str,
                 name: str,
                 network_type: str,
                 status: str,
                 transit_gateway: 'TransitGatewayReference',
                 *,
                 base_connection_id: str = None,
                 local_bgp_asn: int = None,
                 local_gateway_ip: str = None,
                 local_tunnel_ip: str = None,
                 mtu: int = None,
                 network_account_id: str = None,
                 network_id: str = None,
                 remote_bgp_asn: int = None,
                 remote_gateway_ip: str = None,
                 remote_tunnel_ip: str = None,
                 request_status: str = None,
                 updated_at: datetime = None,
                 zone: 'ZoneReference' = None) -> None:
        """
        Initialize a TransitConnection object.

        :param datetime created_at: The date and time that this connection was
               created.
        :param str id: The unique identifier for this connection.
        :param str name: The user-defined name for this transit gateway connection.
        :param str network_type: Defines what type of network is connected via this
               connection. The list of enumerated values for this property may expand in
               the future. Code and processes using this field must tolerate unexpected
               values.
        :param str status: Connection state. The list of enumerated values for this
               property may expand in the future. Code and processes using this field must
               tolerate unexpected values.
        :param TransitGatewayReference transit_gateway: Reference to the transit
               gateway that contains this connection.
        :param str base_connection_id: (optional) network_type 'gre_tunnel'
               connections use 'base_connection_id' to specify the id of a network_type
               'classic' connection the tunnel is configured over. The specified
               connection must reside in the same transit gateway and be in an active
               state. The 'classic' connection cannot be deleted until any 'gre_tunnel'
               connections using it are deleted. This field only applies to and is
               required for network type 'gre_tunnel' connections.
        :param int local_bgp_asn: (optional) Local network BGP ASN.  This field
               only applies to network type 'gre_tunnel' connections.
        :param str local_gateway_ip: (optional) Local gateway IP address.  This
               field only applies to network type 'gre_tunnel' connections.
        :param str local_tunnel_ip: (optional) Local tunnel IP address.  This field
               only applies to network type 'gre_tunnel' connections.
        :param int mtu: (optional) GRE tunnel MTU.  This field only applies to
               network type 'gre_tunnel' connections.
        :param str network_account_id: (optional) The ID of the account which owns
               the connected network. Generally only used if the network is in a different
               IBM Cloud account than the gateway.
        :param str network_id: (optional) The ID of the network being connected via
               this connection. This field is required for some types, such as 'vpc'. For
               network type 'vpc' this is the CRN of the VPC to be connected.
        :param int remote_bgp_asn: (optional) Remote network BGP ASN.  This field
               only applies to network type 'gre_tunnel' connections.
        :param str remote_gateway_ip: (optional) Remote gateway IP address.  This
               field only applies to network type 'gre_tunnel' connections.
        :param str remote_tunnel_ip: (optional) Remote tunnel IP address.  This
               field only applies to network type 'gre_tunnel' connections.
        :param str request_status: (optional) Only visible for cross account
               connections, this field represents the status of a connection request
               between IBM Cloud accounts. The list of enumerated values for this property
               may expand in the future. Code and processes using this field must tolerate
               unexpected values.
        :param datetime updated_at: (optional) The date and time that this
               connection was last updated.
        :param ZoneReference zone: (optional) Location of GRE tunnel.  This field
               only applies to network type 'gre_tunnel' connections.
        """
        self.base_connection_id = base_connection_id
        self.created_at = created_at
        self.id = id
        self.local_bgp_asn = local_bgp_asn
        self.local_gateway_ip = local_gateway_ip
        self.local_tunnel_ip = local_tunnel_ip
        self.mtu = mtu
        self.name = name
        self.network_account_id = network_account_id
        self.network_id = network_id
        self.network_type = network_type
        self.remote_bgp_asn = remote_bgp_asn
        self.remote_gateway_ip = remote_gateway_ip
        self.remote_tunnel_ip = remote_tunnel_ip
        self.request_status = request_status
        self.status = status
        self.transit_gateway = transit_gateway
        self.updated_at = updated_at
        self.zone = zone

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitConnection':
        """Initialize a TransitConnection object from a json dictionary."""
        args = {}
        if 'base_connection_id' in _dict:
            args['base_connection_id'] = _dict.get('base_connection_id')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in TransitConnection JSON')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in TransitConnection JSON')
        if 'local_bgp_asn' in _dict:
            args['local_bgp_asn'] = _dict.get('local_bgp_asn')
        if 'local_gateway_ip' in _dict:
            args['local_gateway_ip'] = _dict.get('local_gateway_ip')
        if 'local_tunnel_ip' in _dict:
            args['local_tunnel_ip'] = _dict.get('local_tunnel_ip')
        if 'mtu' in _dict:
            args['mtu'] = _dict.get('mtu')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TransitConnection JSON')
        if 'network_account_id' in _dict:
            args['network_account_id'] = _dict.get('network_account_id')
        if 'network_id' in _dict:
            args['network_id'] = _dict.get('network_id')
        if 'network_type' in _dict:
            args['network_type'] = _dict.get('network_type')
        else:
            raise ValueError('Required property \'network_type\' not present in TransitConnection JSON')
        if 'remote_bgp_asn' in _dict:
            args['remote_bgp_asn'] = _dict.get('remote_bgp_asn')
        if 'remote_gateway_ip' in _dict:
            args['remote_gateway_ip'] = _dict.get('remote_gateway_ip')
        if 'remote_tunnel_ip' in _dict:
            args['remote_tunnel_ip'] = _dict.get('remote_tunnel_ip')
        if 'request_status' in _dict:
            args['request_status'] = _dict.get('request_status')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        else:
            raise ValueError('Required property \'status\' not present in TransitConnection JSON')
        if 'transit_gateway' in _dict:
            args['transit_gateway'] = TransitGatewayReference.from_dict(_dict.get('transit_gateway'))
        else:
            raise ValueError('Required property \'transit_gateway\' not present in TransitConnection JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'zone' in _dict:
            args['zone'] = ZoneReference.from_dict(_dict.get('zone'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitConnection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'base_connection_id') and self.base_connection_id is not None:
            _dict['base_connection_id'] = self.base_connection_id
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'local_bgp_asn') and self.local_bgp_asn is not None:
            _dict['local_bgp_asn'] = self.local_bgp_asn
        if hasattr(self, 'local_gateway_ip') and self.local_gateway_ip is not None:
            _dict['local_gateway_ip'] = self.local_gateway_ip
        if hasattr(self, 'local_tunnel_ip') and self.local_tunnel_ip is not None:
            _dict['local_tunnel_ip'] = self.local_tunnel_ip
        if hasattr(self, 'mtu') and self.mtu is not None:
            _dict['mtu'] = self.mtu
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'network_account_id') and self.network_account_id is not None:
            _dict['network_account_id'] = self.network_account_id
        if hasattr(self, 'network_id') and self.network_id is not None:
            _dict['network_id'] = self.network_id
        if hasattr(self, 'network_type') and self.network_type is not None:
            _dict['network_type'] = self.network_type
        if hasattr(self, 'remote_bgp_asn') and self.remote_bgp_asn is not None:
            _dict['remote_bgp_asn'] = self.remote_bgp_asn
        if hasattr(self, 'remote_gateway_ip') and self.remote_gateway_ip is not None:
            _dict['remote_gateway_ip'] = self.remote_gateway_ip
        if hasattr(self, 'remote_tunnel_ip') and self.remote_tunnel_ip is not None:
            _dict['remote_tunnel_ip'] = self.remote_tunnel_ip
        if hasattr(self, 'request_status') and self.request_status is not None:
            _dict['request_status'] = self.request_status
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status
        if hasattr(self, 'transit_gateway') and self.transit_gateway is not None:
            _dict['transit_gateway'] = self.transit_gateway.to_dict()
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'zone') and self.zone is not None:
            _dict['zone'] = self.zone.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitConnection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitConnection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitConnection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class NetworkTypeEnum(str, Enum):
        """
        Defines what type of network is connected via this connection. The list of
        enumerated values for this property may expand in the future. Code and processes
        using this field must tolerate unexpected values.
        """
        VPC = 'vpc'
        CLASSIC = 'classic'
        GRE_TUNNEL = 'gre_tunnel'


    class RequestStatusEnum(str, Enum):
        """
        Only visible for cross account connections, this field represents the status of a
        connection request between IBM Cloud accounts. The list of enumerated values for
        this property may expand in the future. Code and processes using this field must
        tolerate unexpected values.
        """
        PENDING = 'pending'
        APPROVED = 'approved'
        REJECTED = 'rejected'
        EXPIRED = 'expired'
        DETACHED = 'detached'


    class StatusEnum(str, Enum):
        """
        Connection state. The list of enumerated values for this property may expand in
        the future. Code and processes using this field must tolerate unexpected values.
        """
        ATTACHED = 'attached'
        FAILED = 'failed'
        PENDING = 'pending'
        DELETING = 'deleting'
        DETACHING = 'detaching'
        DETACHED = 'detached'


class TransitConnectionCollection():
    """
    Transit gateway connections.

    :attr List[TransitConnection] connections: Array of transit gateway connections.
    :attr TransitConnectionCollectionFirst first: A reference to the first page of
          resources.
    :attr int limit: The maximum number of connections returned on one request.
    :attr TransitConnectionCollectionNext next: (optional) A reference to the next
          page of resources; this reference is included for all pages except the last
          page.
    """

    def __init__(self,
                 connections: List['TransitConnection'],
                 first: 'TransitConnectionCollectionFirst',
                 limit: int,
                 *,
                 next: 'TransitConnectionCollectionNext' = None) -> None:
        """
        Initialize a TransitConnectionCollection object.

        :param List[TransitConnection] connections: Array of transit gateway
               connections.
        :param TransitConnectionCollectionFirst first: A reference to the first
               page of resources.
        :param int limit: The maximum number of connections returned on one
               request.
        :param TransitConnectionCollectionNext next: (optional) A reference to the
               next page of resources; this reference is included for all pages except the
               last page.
        """
        self.connections = connections
        self.first = first
        self.limit = limit
        self.next = next

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitConnectionCollection':
        """Initialize a TransitConnectionCollection object from a json dictionary."""
        args = {}
        if 'connections' in _dict:
            args['connections'] = [TransitConnection.from_dict(x) for x in _dict.get('connections')]
        else:
            raise ValueError('Required property \'connections\' not present in TransitConnectionCollection JSON')
        if 'first' in _dict:
            args['first'] = TransitConnectionCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in TransitConnectionCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in TransitConnectionCollection JSON')
        if 'next' in _dict:
            args['next'] = TransitConnectionCollectionNext.from_dict(_dict.get('next'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitConnectionCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'connections') and self.connections is not None:
            _dict['connections'] = [x.to_dict() for x in self.connections]
        if hasattr(self, 'first') and self.first is not None:
            _dict['first'] = self.first.to_dict()
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'next') and self.next is not None:
            _dict['next'] = self.next.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitConnectionCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitConnectionCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitConnectionCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TransitConnectionCollectionFirst():
    """
    A reference to the first page of resources.

    :attr str href: url.
    """

    def __init__(self,
                 href: str) -> None:
        """
        Initialize a TransitConnectionCollectionFirst object.

        :param str href: url.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitConnectionCollectionFirst':
        """Initialize a TransitConnectionCollectionFirst object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in TransitConnectionCollectionFirst JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitConnectionCollectionFirst object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitConnectionCollectionFirst object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitConnectionCollectionFirst') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitConnectionCollectionFirst') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TransitConnectionCollectionNext():
    """
    A reference to the next page of resources; this reference is included for all pages
    except the last page.

    :attr str href: (optional) url.
    :attr str start: (optional) server generated start token for next page of
          resources.
    """

    def __init__(self,
                 *,
                 href: str = None,
                 start: str = None) -> None:
        """
        Initialize a TransitConnectionCollectionNext object.

        :param str href: (optional) url.
        :param str start: (optional) server generated start token for next page of
               resources.
        """
        self.href = href
        self.start = start

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitConnectionCollectionNext':
        """Initialize a TransitConnectionCollectionNext object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        if 'start' in _dict:
            args['start'] = _dict.get('start')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitConnectionCollectionNext object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        if hasattr(self, 'start') and self.start is not None:
            _dict['start'] = self.start
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitConnectionCollectionNext object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitConnectionCollectionNext') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitConnectionCollectionNext') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TransitGateway():
    """
    Details of a Transit Gateway.

    :attr str id: The unique identifier for this Transit Gateway.
    :attr str crn: The CRN for this Transit Gateway.
    :attr str name: A human readable name for the transit gateway.
    :attr str location: Location of Transit Gateway Services.
    :attr datetime created_at: The date and time that this gateway was created.
    :attr bool global_: Allow global routing for a Transit Gateway.
    :attr ResourceGroupReference resource_group: (optional) The resource group to
          use. If unspecified, the account's [default resource
          group](https://console.bluemix.net/apidocs/resource-manager#introduction) is
          used.
    :attr str status: The status of the Transit Gateway. The list of enumerated
          values for this property may expand in the future. Code and processes using this
          field must tolerate unexpected values.
    :attr datetime updated_at: (optional) The date and time that this gateway was
          last updated.
    """

    def __init__(self,
                 id: str,
                 crn: str,
                 name: str,
                 location: str,
                 created_at: datetime,
                 global_: bool,
                 status: str,
                 *,
                 resource_group: 'ResourceGroupReference' = None,
                 updated_at: datetime = None) -> None:
        """
        Initialize a TransitGateway object.

        :param str id: The unique identifier for this Transit Gateway.
        :param str crn: The CRN for this Transit Gateway.
        :param str name: A human readable name for the transit gateway.
        :param str location: Location of Transit Gateway Services.
        :param datetime created_at: The date and time that this gateway was
               created.
        :param bool global_: Allow global routing for a Transit Gateway.
        :param str status: The status of the Transit Gateway. The list of
               enumerated values for this property may expand in the future. Code and
               processes using this field must tolerate unexpected values.
        :param ResourceGroupReference resource_group: (optional) The resource group
               to use. If unspecified, the account's [default resource
               group](https://console.bluemix.net/apidocs/resource-manager#introduction)
               is used.
        :param datetime updated_at: (optional) The date and time that this gateway
               was last updated.
        """
        self.id = id
        self.crn = crn
        self.name = name
        self.location = location
        self.created_at = created_at
        self.global_ = global_
        self.resource_group = resource_group
        self.status = status
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitGateway':
        """Initialize a TransitGateway object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in TransitGateway JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in TransitGateway JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TransitGateway JSON')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        else:
            raise ValueError('Required property \'location\' not present in TransitGateway JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in TransitGateway JSON')
        if 'global' in _dict:
            args['global_'] = _dict.get('global')
        else:
            raise ValueError('Required property \'global\' not present in TransitGateway JSON')
        if 'resource_group' in _dict:
            args['resource_group'] = ResourceGroupReference.from_dict(_dict.get('resource_group'))
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        else:
            raise ValueError('Required property \'status\' not present in TransitGateway JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitGateway object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'global_') and self.global_ is not None:
            _dict['global'] = self.global_
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group.to_dict()
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitGateway object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitGateway') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitGateway') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusEnum(str, Enum):
        """
        The status of the Transit Gateway. The list of enumerated values for this property
        may expand in the future. Code and processes using this field must tolerate
        unexpected values.
        """
        AVAILABLE = 'available'
        FAILED = 'failed'
        PENDING = 'pending'
        DELETING = 'deleting'


class TransitGatewayCollection():
    """
    A list of Transit Gateways.

    :attr TransitGatewayCollectionFirst first: A reference to the first page of
          resources.
    :attr int limit: The maximum number of gateways returned on one request.
    :attr TransitGatewayCollectionNext next: (optional) A reference to the next page
          of resources; this reference is included for all pages except the last page.
    :attr List[TransitGateway] transit_gateways: Collection of Transit Services
          gateways.
    """

    def __init__(self,
                 first: 'TransitGatewayCollectionFirst',
                 limit: int,
                 transit_gateways: List['TransitGateway'],
                 *,
                 next: 'TransitGatewayCollectionNext' = None) -> None:
        """
        Initialize a TransitGatewayCollection object.

        :param TransitGatewayCollectionFirst first: A reference to the first page
               of resources.
        :param int limit: The maximum number of gateways returned on one request.
        :param List[TransitGateway] transit_gateways: Collection of Transit
               Services gateways.
        :param TransitGatewayCollectionNext next: (optional) A reference to the
               next page of resources; this reference is included for all pages except the
               last page.
        """
        self.first = first
        self.limit = limit
        self.next = next
        self.transit_gateways = transit_gateways

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitGatewayCollection':
        """Initialize a TransitGatewayCollection object from a json dictionary."""
        args = {}
        if 'first' in _dict:
            args['first'] = TransitGatewayCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in TransitGatewayCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in TransitGatewayCollection JSON')
        if 'next' in _dict:
            args['next'] = TransitGatewayCollectionNext.from_dict(_dict.get('next'))
        if 'transit_gateways' in _dict:
            args['transit_gateways'] = [TransitGateway.from_dict(x) for x in _dict.get('transit_gateways')]
        else:
            raise ValueError('Required property \'transit_gateways\' not present in TransitGatewayCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitGatewayCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'first') and self.first is not None:
            _dict['first'] = self.first.to_dict()
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'next') and self.next is not None:
            _dict['next'] = self.next.to_dict()
        if hasattr(self, 'transit_gateways') and self.transit_gateways is not None:
            _dict['transit_gateways'] = [x.to_dict() for x in self.transit_gateways]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitGatewayCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitGatewayCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitGatewayCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TransitGatewayCollectionFirst():
    """
    A reference to the first page of resources.

    :attr str href: url.
    """

    def __init__(self,
                 href: str) -> None:
        """
        Initialize a TransitGatewayCollectionFirst object.

        :param str href: url.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitGatewayCollectionFirst':
        """Initialize a TransitGatewayCollectionFirst object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in TransitGatewayCollectionFirst JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitGatewayCollectionFirst object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitGatewayCollectionFirst object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitGatewayCollectionFirst') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitGatewayCollectionFirst') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TransitGatewayCollectionNext():
    """
    A reference to the next page of resources; this reference is included for all pages
    except the last page.

    :attr str href: url.
    :attr str start: server generated start token for next page of resources.
    """

    def __init__(self,
                 href: str,
                 start: str) -> None:
        """
        Initialize a TransitGatewayCollectionNext object.

        :param str href: url.
        :param str start: server generated start token for next page of resources.
        """
        self.href = href
        self.start = start

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitGatewayCollectionNext':
        """Initialize a TransitGatewayCollectionNext object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in TransitGatewayCollectionNext JSON')
        if 'start' in _dict:
            args['start'] = _dict.get('start')
        else:
            raise ValueError('Required property \'start\' not present in TransitGatewayCollectionNext JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitGatewayCollectionNext object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        if hasattr(self, 'start') and self.start is not None:
            _dict['start'] = self.start
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitGatewayCollectionNext object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitGatewayCollectionNext') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitGatewayCollectionNext') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TransitGatewayConnectionCollection():
    """
    A set of Transit Gateway network connections.

    :attr List[TransitGatewayConnectionCust] connections: Array of transit gateways
          network Connections.
    """

    def __init__(self,
                 connections: List['TransitGatewayConnectionCust']) -> None:
        """
        Initialize a TransitGatewayConnectionCollection object.

        :param List[TransitGatewayConnectionCust] connections: Array of transit
               gateways network Connections.
        """
        self.connections = connections

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitGatewayConnectionCollection':
        """Initialize a TransitGatewayConnectionCollection object from a json dictionary."""
        args = {}
        if 'connections' in _dict:
            args['connections'] = [TransitGatewayConnectionCust.from_dict(x) for x in _dict.get('connections')]
        else:
            raise ValueError('Required property \'connections\' not present in TransitGatewayConnectionCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitGatewayConnectionCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'connections') and self.connections is not None:
            _dict['connections'] = [x.to_dict() for x in self.connections]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitGatewayConnectionCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitGatewayConnectionCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitGatewayConnectionCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TransitGatewayConnectionCust():
    """
    Connection included in transit gateway.

    :attr str name: The user-defined name for this transit gateway connection.
    :attr str network_id: (optional) The ID of the network being connected via this
          connection. This field is required for some types, such as 'vpc'. For network
          type 'vpc' this is the CRN of the VPC to be connected.
    :attr str network_type: Defines what type of network is connected via this
          connection. The list of enumerated values for this property may expand in the
          future. Code and processes using this field must tolerate unexpected values.
    :attr str id: The unique identifier for this Transit Gateway Connection.
    :attr str base_connection_id: (optional) network_type 'gre_tunnel' connections
          use 'base_connection_id' to specify the ID of a network_type 'classic'
          connection the tunnel is configured over. The specified connection must reside
          in the same transit gateway and be in an active state. The 'classic' connection
          cannot be deleted until any 'gre_tunnel' connections using it are deleted. This
          field only applies to and is required for network type 'gre_tunnel' connections.
    :attr datetime created_at: The date and time that this connection was created.
    :attr int local_bgp_asn: (optional) Local network BGP ASN.  This field only
          applies to network type 'gre_tunnel' connections.
    :attr str local_gateway_ip: (optional) Local gateway IP address.  This field
          only applies to network type 'gre_tunnel' connections.
    :attr str local_tunnel_ip: (optional) Local tunnel IP address.  This field only
          applies to network type 'gre_tunnel' connections.
    :attr int mtu: (optional) GRE tunnel MTU.  This field only applies to network
          type 'gre_tunnel' connections.
    :attr str network_account_id: (optional) The ID of the account which owns the
          connected network. Generally only used if the network is in a different IBM
          Cloud account than the gateway.
    :attr int remote_bgp_asn: (optional) Remote network BGP ASN.  This field only
          applies to network type 'gre_tunnel' connections.
    :attr str remote_gateway_ip: (optional) Remote gateway IP address.  This field
          only applies to network type 'gre_tunnel' connections.
    :attr str remote_tunnel_ip: (optional) Remote tunnel IP address.  This field
          only applies to network type 'gre_tunnel' connections.
    :attr str request_status: (optional) Only visible for cross account connections,
          this field represents the status of a connection request between IBM Cloud
          accounts. The list of enumerated values for this property may expand in the
          future. Code and processes using this field must tolerate unexpected values.
    :attr str status: (optional) Connection's current configuration state. The list
          of enumerated values for this property may expand in the future. Code and
          processes using this field must tolerate unexpected values.
    :attr datetime updated_at: (optional) The date and time that this connection was
          last updated.
    :attr TransitGatewayConnectionCustZone zone: (optional) Location of GRE tunnel.
          This field only applies to network type 'gre_tunnel' connections.
    """

    def __init__(self,
                 name: str,
                 network_type: str,
                 id: str,
                 created_at: datetime,
                 *,
                 network_id: str = None,
                 base_connection_id: str = None,
                 local_bgp_asn: int = None,
                 local_gateway_ip: str = None,
                 local_tunnel_ip: str = None,
                 mtu: int = None,
                 network_account_id: str = None,
                 remote_bgp_asn: int = None,
                 remote_gateway_ip: str = None,
                 remote_tunnel_ip: str = None,
                 request_status: str = None,
                 status: str = None,
                 updated_at: datetime = None,
                 zone: 'TransitGatewayConnectionCustZone' = None) -> None:
        """
        Initialize a TransitGatewayConnectionCust object.

        :param str name: The user-defined name for this transit gateway connection.
        :param str network_type: Defines what type of network is connected via this
               connection. The list of enumerated values for this property may expand in
               the future. Code and processes using this field must tolerate unexpected
               values.
        :param str id: The unique identifier for this Transit Gateway Connection.
        :param datetime created_at: The date and time that this connection was
               created.
        :param str network_id: (optional) The ID of the network being connected via
               this connection. This field is required for some types, such as 'vpc'. For
               network type 'vpc' this is the CRN of the VPC to be connected.
        :param str base_connection_id: (optional) network_type 'gre_tunnel'
               connections use 'base_connection_id' to specify the ID of a network_type
               'classic' connection the tunnel is configured over. The specified
               connection must reside in the same transit gateway and be in an active
               state. The 'classic' connection cannot be deleted until any 'gre_tunnel'
               connections using it are deleted. This field only applies to and is
               required for network type 'gre_tunnel' connections.
        :param int local_bgp_asn: (optional) Local network BGP ASN.  This field
               only applies to network type 'gre_tunnel' connections.
        :param str local_gateway_ip: (optional) Local gateway IP address.  This
               field only applies to network type 'gre_tunnel' connections.
        :param str local_tunnel_ip: (optional) Local tunnel IP address.  This field
               only applies to network type 'gre_tunnel' connections.
        :param int mtu: (optional) GRE tunnel MTU.  This field only applies to
               network type 'gre_tunnel' connections.
        :param str network_account_id: (optional) The ID of the account which owns
               the connected network. Generally only used if the network is in a different
               IBM Cloud account than the gateway.
        :param int remote_bgp_asn: (optional) Remote network BGP ASN.  This field
               only applies to network type 'gre_tunnel' connections.
        :param str remote_gateway_ip: (optional) Remote gateway IP address.  This
               field only applies to network type 'gre_tunnel' connections.
        :param str remote_tunnel_ip: (optional) Remote tunnel IP address.  This
               field only applies to network type 'gre_tunnel' connections.
        :param str request_status: (optional) Only visible for cross account
               connections, this field represents the status of a connection request
               between IBM Cloud accounts. The list of enumerated values for this property
               may expand in the future. Code and processes using this field must tolerate
               unexpected values.
        :param str status: (optional) Connection's current configuration state. The
               list of enumerated values for this property may expand in the future. Code
               and processes using this field must tolerate unexpected values.
        :param datetime updated_at: (optional) The date and time that this
               connection was last updated.
        :param TransitGatewayConnectionCustZone zone: (optional) Location of GRE
               tunnel.  This field only applies to network type 'gre_tunnel' connections.
        """
        self.name = name
        self.network_id = network_id
        self.network_type = network_type
        self.id = id
        self.base_connection_id = base_connection_id
        self.created_at = created_at
        self.local_bgp_asn = local_bgp_asn
        self.local_gateway_ip = local_gateway_ip
        self.local_tunnel_ip = local_tunnel_ip
        self.mtu = mtu
        self.network_account_id = network_account_id
        self.remote_bgp_asn = remote_bgp_asn
        self.remote_gateway_ip = remote_gateway_ip
        self.remote_tunnel_ip = remote_tunnel_ip
        self.request_status = request_status
        self.status = status
        self.updated_at = updated_at
        self.zone = zone

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitGatewayConnectionCust':
        """Initialize a TransitGatewayConnectionCust object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TransitGatewayConnectionCust JSON')
        if 'network_id' in _dict:
            args['network_id'] = _dict.get('network_id')
        if 'network_type' in _dict:
            args['network_type'] = _dict.get('network_type')
        else:
            raise ValueError('Required property \'network_type\' not present in TransitGatewayConnectionCust JSON')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in TransitGatewayConnectionCust JSON')
        if 'base_connection_id' in _dict:
            args['base_connection_id'] = _dict.get('base_connection_id')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in TransitGatewayConnectionCust JSON')
        if 'local_bgp_asn' in _dict:
            args['local_bgp_asn'] = _dict.get('local_bgp_asn')
        if 'local_gateway_ip' in _dict:
            args['local_gateway_ip'] = _dict.get('local_gateway_ip')
        if 'local_tunnel_ip' in _dict:
            args['local_tunnel_ip'] = _dict.get('local_tunnel_ip')
        if 'mtu' in _dict:
            args['mtu'] = _dict.get('mtu')
        if 'network_account_id' in _dict:
            args['network_account_id'] = _dict.get('network_account_id')
        if 'remote_bgp_asn' in _dict:
            args['remote_bgp_asn'] = _dict.get('remote_bgp_asn')
        if 'remote_gateway_ip' in _dict:
            args['remote_gateway_ip'] = _dict.get('remote_gateway_ip')
        if 'remote_tunnel_ip' in _dict:
            args['remote_tunnel_ip'] = _dict.get('remote_tunnel_ip')
        if 'request_status' in _dict:
            args['request_status'] = _dict.get('request_status')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'zone' in _dict:
            args['zone'] = TransitGatewayConnectionCustZone.from_dict(_dict.get('zone'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitGatewayConnectionCust object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'network_id') and self.network_id is not None:
            _dict['network_id'] = self.network_id
        if hasattr(self, 'network_type') and self.network_type is not None:
            _dict['network_type'] = self.network_type
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'base_connection_id') and self.base_connection_id is not None:
            _dict['base_connection_id'] = self.base_connection_id
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'local_bgp_asn') and self.local_bgp_asn is not None:
            _dict['local_bgp_asn'] = self.local_bgp_asn
        if hasattr(self, 'local_gateway_ip') and self.local_gateway_ip is not None:
            _dict['local_gateway_ip'] = self.local_gateway_ip
        if hasattr(self, 'local_tunnel_ip') and self.local_tunnel_ip is not None:
            _dict['local_tunnel_ip'] = self.local_tunnel_ip
        if hasattr(self, 'mtu') and self.mtu is not None:
            _dict['mtu'] = self.mtu
        if hasattr(self, 'network_account_id') and self.network_account_id is not None:
            _dict['network_account_id'] = self.network_account_id
        if hasattr(self, 'remote_bgp_asn') and self.remote_bgp_asn is not None:
            _dict['remote_bgp_asn'] = self.remote_bgp_asn
        if hasattr(self, 'remote_gateway_ip') and self.remote_gateway_ip is not None:
            _dict['remote_gateway_ip'] = self.remote_gateway_ip
        if hasattr(self, 'remote_tunnel_ip') and self.remote_tunnel_ip is not None:
            _dict['remote_tunnel_ip'] = self.remote_tunnel_ip
        if hasattr(self, 'request_status') and self.request_status is not None:
            _dict['request_status'] = self.request_status
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'zone') and self.zone is not None:
            _dict['zone'] = self.zone.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitGatewayConnectionCust object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitGatewayConnectionCust') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitGatewayConnectionCust') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class NetworkTypeEnum(str, Enum):
        """
        Defines what type of network is connected via this connection. The list of
        enumerated values for this property may expand in the future. Code and processes
        using this field must tolerate unexpected values.
        """
        VPC = 'vpc'
        CLASSIC = 'classic'
        GRE_TUNNEL = 'gre_tunnel'


    class RequestStatusEnum(str, Enum):
        """
        Only visible for cross account connections, this field represents the status of a
        connection request between IBM Cloud accounts. The list of enumerated values for
        this property may expand in the future. Code and processes using this field must
        tolerate unexpected values.
        """
        PENDING = 'pending'
        APPROVED = 'approved'
        REJECTED = 'rejected'
        EXPIRED = 'expired'
        DETACHED = 'detached'


    class StatusEnum(str, Enum):
        """
        Connection's current configuration state. The list of enumerated values for this
        property may expand in the future. Code and processes using this field must
        tolerate unexpected values.
        """
        ATTACHED = 'attached'
        FAILED = 'failed'
        PENDING = 'pending'
        DELETING = 'deleting'
        DETACHING = 'detaching'
        DETACHED = 'detached'


class TransitGatewayConnectionCustZone():
    """
    Location of GRE tunnel.  This field only applies to network type 'gre_tunnel'
    connections.

    :attr str name: Availability zone name.
    """

    def __init__(self,
                 name: str) -> None:
        """
        Initialize a TransitGatewayConnectionCustZone object.

        :param str name: Availability zone name.
        """
        self.name = name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitGatewayConnectionCustZone':
        """Initialize a TransitGatewayConnectionCustZone object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TransitGatewayConnectionCustZone JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitGatewayConnectionCustZone object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitGatewayConnectionCustZone object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitGatewayConnectionCustZone') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitGatewayConnectionCustZone') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TransitGatewayReference():
    """
    Transit gateway reference.

    :attr str crn: gateway CRN.
    :attr str id: gateway ID.
    :attr str name: transit gateway name.
    """

    def __init__(self,
                 crn: str,
                 id: str,
                 name: str) -> None:
        """
        Initialize a TransitGatewayReference object.

        :param str crn: gateway CRN.
        :param str id: gateway ID.
        :param str name: transit gateway name.
        """
        self.crn = crn
        self.id = id
        self.name = name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TransitGatewayReference':
        """Initialize a TransitGatewayReference object from a json dictionary."""
        args = {}
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in TransitGatewayReference JSON')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in TransitGatewayReference JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TransitGatewayReference JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TransitGatewayReference object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TransitGatewayReference object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TransitGatewayReference') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TransitGatewayReference') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ZoneIdentity():
    """
    ZoneIdentity.

    """

    def __init__(self) -> None:
        """
        Initialize a ZoneIdentity object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
                  ", ".join(['ZoneIdentityByName']))
        raise Exception(msg)

class ZoneReference():
    """
    Availability zone reference.

    :attr str name: Availability zone name.
    """

    def __init__(self,
                 name: str) -> None:
        """
        Initialize a ZoneReference object.

        :param str name: Availability zone name.
        """
        self.name = name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ZoneReference':
        """Initialize a ZoneReference object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in ZoneReference JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ZoneReference object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ZoneReference object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ZoneReference') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ZoneReference') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ZoneIdentityByName(ZoneIdentity):
    """
    Availability zone.

    :attr str name: (optional) Availability zone name.
    """

    def __init__(self,
                 *,
                 name: str = None) -> None:
        """
        Initialize a ZoneIdentityByName object.

        :param str name: (optional) Availability zone name.
        """
        # pylint: disable=super-init-not-called
        self.name = name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ZoneIdentityByName':
        """Initialize a ZoneIdentityByName object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ZoneIdentityByName object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ZoneIdentityByName object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ZoneIdentityByName') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ZoneIdentityByName') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other
